JavaScript
标准参考教程
第二十篇

JavaScript引擎

浏览器,
渲染引擎
JS解释器

渲染引擎,
Firefox Gecko
Safari Webkit
Chrome Blink;

页面渲染流程,
解析----html =>DOM css =>CSSOM,
合并----DOM和CSSOM合成一棵渲染树,
布局------------完成渲染树的布局,
绘制------------渲染树绘制到屏幕

并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。
我们会看到这种情况：网页HTML代码还没下载完，但浏览器可以显示内容了

JavaScript引擎,
读取网页中的代码，对其处理后运行

网页嵌入JS的方法,
<script>// some code here...</script>
<script src="//dataeye.com"></script>
<a href="javascript:alert(1234)"></a>

script标签的工作原理,
1--------------------浏览器一边下载HTML网页，一边开始解析
2-----------------------------解析过程中，发现script标签
3-----------暂停解析，网页渲染的控制权转交给JavaScript引擎
4-如果script标签引用了外部脚本，就下载该脚本，否则就直接执行
5--------执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页

阻塞效应,
外部资源(JS/CSS)加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态

并发连接数,
于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般最多同时下载六个（IE11允许同时下载13个）

defer,
<script src="" defer></script>
并发下载脚本待DOM加载完再执行脚本
动态生成script标签该属性不起作用

async,
<script src="" async></script>
脚本下载的同时，浏览器继续渲染页面
无法保证脚本执行顺序，先下载先执行
脚本内不应使用document.write方法

defer or async?
脚本与其它脚本的依赖关系，比如加载一个第三方SDK

重流和重绘,
渲染树转换为网页布局，称为“布局流”（flow）
布局显示到页面这个过程，称为“绘制”（paint）

重流和重绘具有阻塞效应,并且会耗费很多时间和计算资源

重流必然导致重绘，重绘不一定需要重流,
比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流

优化技巧

<script src="//example.js"></script>

JavaScript虚拟机

单线程模型,
所有的任务都在一个线程里运行。一次只能运行一个任务，其他任务都必须在后面排队等待

WHY?

Event Loop,
一种内部循环，用来排列和处理事件，以及执行函数。

同步任务,
主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务

异步任务,
不进入主线程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行

先进先出,
“任务队列”就是一个事件“先进先出”的数据结构
比如，点击鼠标就产生一些列事件，mousedown事件排在mouseup事件前面，mouseup事件又排在click事件的前面

结束
http://javascript.ruanyifeng.com/bom/engine.html